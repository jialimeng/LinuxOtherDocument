前一段时间在研发、调试一个virtual scsi host时，遇到了一个锁的问题，这个问题也就是在spinlock的环境中调用了可能睡眠的函数，导致系统崩溃。在此，对这个问题进行一下总结。


从理论上讲spinlock环境是不能睡眠的，这需要分两种情况进行讨论。

1.	在 `spinlock_irq`(关中断)的环境下, 如果上下文context)睡眠, 那么极有可能导致 `Linux` 系统无法正常调度, 并且 `Linux` 的心跳中断服务例程都无法调度, 所以, 很容易导致系统进入崩溃状态.

2.	在 `spinlock`(不关中断)的环境下, 如果上下文睡眠, 那么被调度的上下文极有可能再次访问被锁保护的临界资源, 从而导致系统死锁而崩溃.

`spin_lock` 本身在等待资源的时候, 就会让 CPU 自旋, 也就是死等那那里. 因此 `spin_lock` 中会调用 `"preempt_disable()"`, 即 `"关抢占"`.
此时虽然禁止了抢占, 但是仍可在上下文中, 显式通过调用 scheduler/msleep 等函数让出 CPU. 试想一下, 如果在自旋锁保护的代码中间睡眠, 此时发生进程调度, 则可能另外一个进程会再次调用 `spinlock` 保护的这段代码.
这时候由于之前的上下文已经持有了锁, 这个进程是不能拿到锁的, 只能在原地自旋, 不会
再睡眠, 更不可能调度. 那么死锁自然就发生了.

从上面的分析来看, 在 `spinlock` 保护的范围内是不能睡眠的. 如果睡眠, 将会导致系统的崩溃.

导致死锁的过程：

```cpp
[pid] Action    ...... Comment

[1]   关抢占

[1]   获得锁

[1]   睡眠调度            ...... 尽管已经关闭了抢占，[1]依然可以通过主动调用
schedule(), schedule_timeout()等主动让出CPU，调度其它进程。

[2]   关抢占               ...... [1]已经关闭抢占,所以这里相当于nop操作

[2]   获得锁失败         ...... [1]已经获得了锁，并且还没有释放

[2]   反复尝试获得锁   ...... 由于关闭了抢占，已经没人能够终止这个反复尝试的操作
了，所以这里出现了死锁
```
